#pragma once
#include "TextRenderer.h"

const unsigned long PADDING = 2;

#define UPDATE_TEXT 0
#define DELETE_TEXT 1
#define DELETE_FONT 2

struct TextConst {
	float R,G,B,A;
	float ScaleX,ScaleY;
	float OffsetX, OffsetY;
};

unsigned char TextVertexShaderBinary[664] = {
	0x44, 0x58, 0x42, 0x43, 0x28, 0x44, 0x87, 0xC3, 0xD1, 0x22, 0x06, 0x57,
	0x6A, 0x7C, 0x75, 0x5E, 0x56, 0x6F, 0x01, 0xB3, 0x01, 0x00, 0x00, 0x00,
	0x98, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
	0xB4, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0xA0, 0x01, 0x00, 0x00,
	0xEC, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x41, 0x6F, 0x6E, 0x39,
	0x74, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFE, 0xFF,
	0x4C, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00,
	0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x24, 0x00,
	0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xFE, 0xFF,
	0x1F, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x80, 0x00, 0x00, 0x0F, 0x90,
	0x1F, 0x00, 0x00, 0x02, 0x05, 0x00, 0x01, 0x80, 0x01, 0x00, 0x0F, 0x90,
	0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0xFF, 0x90,
	0x00, 0x00, 0xE4, 0xA0, 0x00, 0x00, 0xE4, 0x90, 0x01, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x03, 0xE0, 0x01, 0x00, 0xE4, 0x90, 0x01, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x0C, 0xC0, 0x00, 0x00, 0xE4, 0x90, 0xFF, 0xFF, 0x00, 0x00,
	0x53, 0x48, 0x44, 0x52, 0x68, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00,
	0x1A, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x03, 0xF2, 0x10, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xF2, 0x20, 0x10, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05,
	0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0xF2, 0x20, 0x10, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46,
	0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFE, 0xFF,
	0x00, 0x01, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x4D, 0x69, 0x63, 0x72,
	0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4C,
	0x53, 0x4C, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6F,
	0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2E, 0x31, 0x00,
	0x49, 0x53, 0x47, 0x4E, 0x4C, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x0F, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x03, 0x03, 0x00, 0x00, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E,
	0x00, 0x54, 0x45, 0x58, 0x43, 0x4F, 0x4F, 0x52, 0x44, 0x00, 0xAB, 0xAB,
	0x4F, 0x53, 0x47, 0x4E, 0x50, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x0C, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4F, 0x4F, 0x52, 0x44,
	0x00, 0x53, 0x56, 0x5F, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E,
	0x00, 0xAB, 0xAB, 0xAB
};

unsigned char TextPixelShaderBinary[936] = {
	0x44, 0x58, 0x42, 0x43, 0xDE, 0xC8, 0xED, 0x71, 0xC3, 0xAB, 0x8C, 0x20,
	0x90, 0x58, 0x1C, 0x84, 0xC3, 0xB8, 0xC7, 0x07, 0x01, 0x00, 0x00, 0x00,
	0xA8, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
	0xC0, 0x00, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00,
	0x40, 0x03, 0x00, 0x00, 0x74, 0x03, 0x00, 0x00, 0x41, 0x6F, 0x6E, 0x39,
	0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF,
	0x4C, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x28, 0x00,
	0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x34, 0x00, 0x01, 0x00, 0x24, 0x00,
	0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xFF, 0xFF,
	0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x03, 0xB0,
	0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x08, 0x0F, 0xA0,
	0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0xB0,
	0x00, 0x08, 0xE4, 0xA0, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80,
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0xE4, 0xA0, 0x01, 0x00, 0x00, 0x02,
	0x00, 0x08, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0x80, 0xFF, 0xFF, 0x00, 0x00,
	0x53, 0x48, 0x44, 0x52, 0x9C, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x27, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8E, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x03,
	0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04,
	0x00, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00,
	0x62, 0x10, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x00, 0x00, 0x03, 0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x68, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x09,
	0xF2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x46, 0x7E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x08,
	0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x46, 0x8E, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54,
	0x74, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x52, 0x44, 0x45, 0x46, 0x58, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x04, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00,
	0x7C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x53, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74,
	0x75, 0x72, 0x65, 0x00, 0x54, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x73,
	0x74, 0x00, 0xAB, 0xAB, 0x8C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0xB0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0xAB, 0xAB,
	0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6C, 0x65, 0x00, 0xAB, 0xAB,
	0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x4D,
	0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29,
	0x20, 0x48, 0x4C, 0x53, 0x4C, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72,
	0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x20, 0x31, 0x30,
	0x2E, 0x31, 0x00, 0xAB, 0x49, 0x53, 0x47, 0x4E, 0x2C, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x54, 0x45, 0x58, 0x43,
	0x4F, 0x4F, 0x52, 0x44, 0x00, 0xAB, 0xAB, 0xAB, 0x4F, 0x53, 0x47, 0x4E,
	0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x53, 0x56, 0x5F, 0x54, 0x41, 0x52, 0x47, 0x45, 0x54, 0x00, 0xAB, 0xAB
};

TS_TextSystem TSCreateTextSystem(ID3D11DeviceContext* Context) {
	TS_TextSystem NewTextSystem;
	NewTextSystem.Context = Context;
	Context->GetDevice(&NewTextSystem.Device);
	//thread related stuff
	NewTextSystem.OwnerThread = GetCurrentThreadId();
	InitializeCriticalSection(&NewTextSystem.CritSection);
	//Creating input layout
	D3D11_INPUT_ELEMENT_DESC ied[2] = {
		{"POSITION",0u,DXGI_FORMAT_R32G32_FLOAT,0u,0u,D3D11_INPUT_PER_VERTEX_DATA,0u},
		{"TEXCOORD",0u,DXGI_FORMAT_R32G32_FLOAT,0u,8u,D3D11_INPUT_PER_VERTEX_DATA,0u}
	};

	NewTextSystem.Device->CreateInputLayout(ied, 2, TextVertexShaderBinary, sizeof TextVertexShaderBinary, &NewTextSystem.InputLayout);
	//Creating shaders
	NewTextSystem.Device->CreateVertexShader(TextVertexShaderBinary, sizeof TextVertexShaderBinary, NULL, &NewTextSystem.VertexShader);
	NewTextSystem.Device->CreatePixelShader(TextPixelShaderBinary, sizeof TextPixelShaderBinary, NULL, &NewTextSystem.PixelShader);
	//Create Sampler state
	D3D11_SAMPLER_DESC SamplerDesc = {};
	SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;

	NewTextSystem.Device->CreateSamplerState(&SamplerDesc, &NewTextSystem.Sampler);
	//Creating Blend State
	D3D11_BLEND_DESC BlendDesc;
	BlendDesc.AlphaToCoverageEnable = FALSE;
	BlendDesc.IndependentBlendEnable = FALSE;
	BlendDesc.RenderTarget[0] = { TRUE ,
		D3D11_BLEND_ONE, D3D11_BLEND_INV_SRC_ALPHA,D3D11_BLEND_OP_ADD,
		D3D11_BLEND_ONE,D3D11_BLEND_INV_SRC_ALPHA,D3D11_BLEND_OP_ADD,
		D3D11_COLOR_WRITE_ENABLE_ALL
	};

	NewTextSystem.Device->CreateBlendState(&BlendDesc, &NewTextSystem.BlendState);
	//Creating Constant Buffer
	D3D11_BUFFER_DESC BufferDesc = {
		sizeof(TextConst),
		D3D11_USAGE_DYNAMIC,
		D3D11_BIND_CONSTANT_BUFFER,
		D3D11_CPU_ACCESS_WRITE,
		0u,
		0u
	};

	TextConst Defaults = { 1.0f,1.0f,1.0f,1.0f,
	1.0f,1.0f,
	0.0f,0.0f };

	D3D11_SUBRESOURCE_DATA SubresourceData = {&Defaults};

	NewTextSystem.Device->CreateBuffer(&BufferDesc, &SubresourceData, &NewTextSystem.TextConstantBuffer);
	
	//Viewport
	unsigned int NumViewPorts = 1u;
	Context->RSGetViewports(&NumViewPorts, &NewTextSystem.Viewport);
	
	return NewTextSystem;
}

TS_FontID TS_TextSystem::TSCreateFont(const char* FontFile, float Size) {
	Font NewFont;
	NewFont.inuse = true;

	FT_Library Ft;
	FT_Face Face;
	unsigned char* TextureData;
	unsigned long CurrentX;
	unsigned long CurrentY;

	if (FT_Init_FreeType(&Ft))
	{
		std::cout << "ERROR::FREETYPE: Could not init FreeType Library" << std::endl;
		return 0xFFFFFFFF;
	}

	if (FT_New_Face(Ft, FontFile, 0, &Face))
	{
		std::cout << "ERROR::FREETYPE: Failed to load font" << std::endl;
		return 0xFFFFFFFF;
	}

	FT_Set_Pixel_Sizes(Face, 0, Size);
	NewFont.Size = Size;

	//Determine the dimensions of the whole atlas
	NewFont.AtlasHeight = 0;
	NewFont.AtlasWidth = 0;
	for (unsigned char Character = 0; Character < 128; Character++) {
		if (FT_Load_Char(Face, Character, FT_LOAD_COMPUTE_METRICS))
		{
			std::cout << "ERROR::FREETYTPE: Failed to load Glyph" << std::endl;
			return 0xFFFFFFFF;
		}
		NewFont.CharacterSet[Character].Width = Face->glyph->metrics.width / 64.0f;
		NewFont.CharacterSet[Character].Height = Face->glyph->metrics.height / 64.0f;
		NewFont.CharacterSet[Character].BearingX = Face->glyph->metrics.horiBearingX / 64.0f;
		NewFont.CharacterSet[Character].BearingY = Face->glyph->metrics.horiBearingY / 64.0f;
		NewFont.CharacterSet[Character].Advance = Face->glyph->metrics.horiAdvance / 64.0f;
		
		NewFont.AtlasWidth = std::max(NewFont.AtlasWidth, (unsigned long)Face->glyph->bitmap.width + PADDING);
		NewFont.AtlasHeight += (unsigned long)Face->glyph->bitmap.rows + PADDING;
	}
	NewFont.AtlasWidth = (unsigned long)powf(2.0f, ceilf(log2f(float(NewFont.AtlasWidth))));
	NewFont.AtlasHeight = (unsigned long)powf(2.0f, ceilf(log2f(float(NewFont.AtlasHeight))));
	printf("%ld:%ld\n", NewFont.AtlasWidth, NewFont.AtlasHeight);

	TextureData = new unsigned char[(size_t)NewFont.AtlasWidth * NewFont.AtlasHeight];
	memset(TextureData, 0, (size_t)NewFont.AtlasWidth * NewFont.AtlasHeight); //make background black
	CurrentX = 0;
	CurrentY = 0;

	//Storing Metrics
	NewFont.Ascender = Face->size->metrics.ascender / 64.0f;
	NewFont.Desender = Face->size->metrics.descender / 64.0f;
	NewFont.MaxLineHeight = Face->size->metrics.height / 64.0f;
	for (unsigned char Character = 0; Character < 128; Character++) {
		if (FT_Load_Char(Face, Character, FT_LOAD_RENDER))
		{
			std::cout << "ERROR::FREETYTPE: Failed to load Glyph" << std::endl;
			return 0xFFFFFFFF;
		}

		unsigned long BitmapWidth = Face->glyph->bitmap.width;
		unsigned long BitmapPitch = Face->glyph->bitmap.pitch;
		unsigned long BitmapHeight = Face->glyph->bitmap.rows;
		unsigned char* Bitmap = Face->glyph->bitmap.buffer;

		if (BitmapWidth == 0 || BitmapHeight == 0 || !Bitmap) continue;

		//Copy Bitmap into atlas
		for (unsigned long i = 0; i < BitmapHeight; i++) {
			memcpy(TextureData + ((size_t)CurrentY + i) * NewFont.AtlasWidth, Bitmap + (size_t)(i)*BitmapPitch, BitmapWidth);
		}

		NewFont.CharacterSet[Character].TexCoordLeft = (float)CurrentX / NewFont.AtlasWidth;
		NewFont.CharacterSet[Character].TexCoordTop = (float)CurrentY / NewFont.AtlasHeight;
		NewFont.CharacterSet[Character].TexCoordRight = (float)(CurrentX + BitmapWidth + 1) / NewFont.AtlasWidth;
		NewFont.CharacterSet[Character].TexCoordBottom = (float)(CurrentY + BitmapHeight + 1) / NewFont.AtlasHeight;

		CurrentY += BitmapHeight + PADDING;

	}

	//Terminating Free type
	FT_Done_Face(Face);
	FT_Done_FreeType(Ft);
	//************************* D3D11 related stuff************************
	//Create Texture 
	D3D11_TEXTURE2D_DESC Tex2DDesc;
	Tex2DDesc.Width = NewFont.AtlasWidth;
	Tex2DDesc.Height = NewFont.AtlasHeight;
	Tex2DDesc.MipLevels = 1;
	Tex2DDesc.ArraySize = 1;
	Tex2DDesc.Format = DXGI_FORMAT_R8_UNORM;
	Tex2DDesc.SampleDesc = { 1,0 };
	Tex2DDesc.Usage = D3D11_USAGE_IMMUTABLE;
	Tex2DDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	Tex2DDesc.CPUAccessFlags = 0;
	Tex2DDesc.MiscFlags = 0;

	D3D11_SUBRESOURCE_DATA sbd = { TextureData,NewFont.AtlasWidth };

	Device->CreateTexture2D(&Tex2DDesc, &sbd, &NewFont.Texture);
	//Create Texture View
	D3D11_SHADER_RESOURCE_VIEW_DESC ShaderResourceViewDesc;
	ShaderResourceViewDesc.Format = DXGI_FORMAT_R8_UNORM;
	ShaderResourceViewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
	ShaderResourceViewDesc.Texture2D = { 0,1 };

	Device->CreateShaderResourceView(NewFont.Texture, &ShaderResourceViewDesc, &NewFont.TextureView);
	
	EnterCriticalSection(&CritSection);
	//Add to the list of fonts
	for (unsigned i = 0; i < Fonts.size(); i++) {
		if (!Fonts[i].inuse) {
			Fonts[i] = std::move(NewFont);
			LeaveCriticalSection(&CritSection);
			return (uint32_t)i;
		}
	}
	Fonts.push_back(std::move(NewFont));
	uint32_t fid = (uint32_t)Fonts.size() - 1;
	LeaveCriticalSection(&CritSection);
	return fid; //return the index of the new font
}

TS_TextID TS_TextSystem::TSCreateText(TS_FontID FontID, const TS_Text_Desc& TextDescription) {
	Text NewText;
	NewText.inuse = true;
	Font& CurrentFont = Fonts[FontID];
	NewText.Xoff = TextDescription.Xoffset;
	NewText.Xscl = TextDescription.Xscale;
	NewText.Yoff = TextDescription.Yoffset;
	NewText.Yscl = TextDescription.Yscale;
	NewText.MaxLineLength = TextDescription.MaxLineLength;
	NewText.Red = TextDescription.Red;
	NewText.Green = TextDescription.Green;
	NewText.Blue = TextDescription.Blue;
	NewText.Alpha = TextDescription.Alpha;
	NewText.Centered = TextDescription.Centered;
	if(*TextDescription.Content != '\0')
		NewText.TextString = TextDescription.Content;
	else
		NewText.TextString = " ";

	//Generting the Mesh
	float CurrentWidthDiv = Viewport.Width/2.0f;
	float CurrentHeightDiv = Viewport.Height/2.0f;
	float CurrentX = 0.0f;
	float CurrentY = -CurrentFont.Ascender;
	unsigned short Index = 0;
	NewText.TextString.reserve(NewText.TextString.size() * 4);
	NewText.Indices.reserve(NewText.TextString.size() * 6);
	for (auto i : NewText.TextString) {
		float Left = CurrentX + CurrentFont.CharacterSet[i].BearingX;
		float Top = CurrentY + CurrentFont.CharacterSet[i].BearingY;
		NewText.Vertices.push_back({ Left, Top, CurrentFont.CharacterSet[i] .TexCoordLeft,CurrentFont.CharacterSet[i].TexCoordTop});
		NewText.Vertices.push_back({ Left + CurrentFont.CharacterSet[i].Width, Top, CurrentFont.CharacterSet[i].TexCoordRight,CurrentFont.CharacterSet[i].TexCoordTop });
		NewText.Vertices.push_back({ Left + CurrentFont.CharacterSet[i].Width, Top - CurrentFont.CharacterSet[i].Height, CurrentFont.CharacterSet[i].TexCoordRight,CurrentFont.CharacterSet[i].TexCoordBottom });
		NewText.Vertices.push_back({ Left , Top - CurrentFont.CharacterSet[i].Height, CurrentFont.CharacterSet[i].TexCoordLeft,CurrentFont.CharacterSet[i].TexCoordBottom });
		NewText.Indices.push_back(Index + 0);
		NewText.Indices.push_back(Index + 1);
		NewText.Indices.push_back(Index + 2);
		NewText.Indices.push_back(Index + 2);
		NewText.Indices.push_back(Index + 3);
		NewText.Indices.push_back(Index + 0);
		Index += 4;
		CurrentX += CurrentFont.CharacterSet[i].Advance;
	}

	std::vector<Vertex> Temporary; //Contain Transformed Vertices
	Temporary.reserve(NewText.Vertices.size());
	for (const auto& Vertexi : NewText.Vertices) {
		Temporary.push_back(Vertexi);
		Vertex& TempVertex = Temporary.back();
		TempVertex.Xpos += NewText.Xoff;
		TempVertex.Ypos += NewText.Yoff;
		TempVertex.Xpos /= CurrentWidthDiv;
		TempVertex.Ypos /= CurrentHeightDiv;
		TempVertex.Xpos += NewText.Xscl;
		TempVertex.Ypos += NewText.Yscl;
	}

	//Vertex buffer
	D3D11_BUFFER_DESC BufferDesc;
	BufferDesc.ByteWidth = NewText.Vertices.size() * sizeof(Vertex);
	BufferDesc.Usage = D3D11_USAGE_DEFAULT;
	BufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	BufferDesc.CPUAccessFlags = 0u;
	BufferDesc.MiscFlags = 0u;
	BufferDesc.StructureByteStride = 0u;

	D3D11_SUBRESOURCE_DATA SubresourceData = { Temporary.data() };
	Device->CreateBuffer(&BufferDesc, &SubresourceData, &NewText.VertexBuffer);
	//Index buffer
	BufferDesc.ByteWidth = NewText.Indices.size() * sizeof(unsigned short);
	BufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
	BufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;

	SubresourceData.pSysMem = NewText.Indices.data();
	Device->CreateBuffer(&BufferDesc, &SubresourceData, &NewText.IndexBuffer);
	
	//add to list of texts
	EnterCriticalSection(&CritSection);
	for (unsigned i = 0; i < CurrentFont.Texts.size(); i++) {
		if (!CurrentFont.Texts[i].inuse) {
			CurrentFont.Texts[i] = std::move(NewText);
			LeaveCriticalSection(&CritSection);
			return (FontID << 16) | (uint16_t)i;
		}
	}
	CurrentFont.Texts.push_back(std::move(NewText));
	uint16_t tid = (uint16_t)CurrentFont.Texts.size() - 1ui16;
	LeaveCriticalSection(&CritSection);
	return (FontID << 16) | tid; //The Text ID
}

void TS_TextSystem::TSUpdateViewport(void) {
	unsigned int NumViewPorts = 1u;
	Context->RSGetViewports(&NumViewPorts, &Viewport);
	
	float CurrentWidthDiv = Viewport.Width / 2.0f;
	float CurrentHeightDiv = Viewport.Height / 2.0f;
	for (const auto& Font : Fonts) {
		for (auto& Text : Font.Texts) {
			std::vector<Vertex> Temporary;
			Temporary.reserve(Text.Vertices.size());
			for (auto& Vertexi : Text.Vertices) {
				Temporary.push_back(Vertexi);
				Vertex& TempVertex = Temporary.back();
				TempVertex.Xpos += Text.Xoff;
				TempVertex.Ypos += Text.Yoff;
				TempVertex.Xpos /= CurrentWidthDiv;
				TempVertex.Ypos /= CurrentHeightDiv;
				TempVertex.Xpos += Text.Xscl;
				TempVertex.Ypos += Text.Yscl;
			}

			Context->UpdateSubresource(Text.VertexBuffer, 0u, NULL, Temporary.data(), 0u, 0u);
		}
	}
}

void TS_TextSystem::TSUpdateText(TS_TextID TextID, const TS_Text_Desc& TextDescription) {
	if (GetCurrentThreadId() != OwnerThread) {
		Command cmd;
		cmd.type = UPDATE_TEXT;
		cmd.UpdateText.TextID = TextID;
		cmd.UpdateText.TextDescription = TextDescription;
		
		char * strptr = (char*)malloc(strlen(TextDescription.Content) + 1);
		strcpy(strptr,TextDescription.Content);
		
		cmd.UpdateText.TextDescription.Content = strptr;
		EnterCriticalSection(&CritSection);
		CommandBuffer.push(cmd);
		LeaveCriticalSection(&CritSection);
		return;
	}
	Font& CurrentFont = Fonts[TextID >> 16];
	Text& CurrentText = CurrentFont.Texts[TextID & 0xFFFF];

	if(TextDescription.ChangeFlags & TS_XOFFSET)
		CurrentText.Xoff = TextDescription.Xoffset;
	if (TextDescription.ChangeFlags & TS_YOFFSET)
		CurrentText.Yoff = TextDescription.Yoffset;
	if (TextDescription.ChangeFlags & TS_MAXLINELENGTH)
		CurrentText.MaxLineLength = TextDescription.MaxLineLength;
	if (TextDescription.ChangeFlags & TS_COLOR) {
		CurrentText.Red = TextDescription.Red;
		CurrentText.Green = TextDescription.Green;
		CurrentText.Blue = TextDescription.Blue;
		CurrentText.Alpha = TextDescription.Alpha;
	}
	if (TextDescription.ChangeFlags & TS_CENTERED)
		CurrentText.Centered = TextDescription.Centered;
	if (TextDescription.ChangeFlags & TS_CONTENT)
		if (*TextDescription.Content != '\0')
			CurrentText.TextString = TextDescription.Content;
		else
			CurrentText.TextString = " ";

	if (TextDescription.ChangeFlags & TS_CONTENT) {
		CurrentText.Vertices.clear();
		CurrentText.Indices.clear();
		//Generting the Mesh
		float CurrentX = CurrentText.Xoff;
		float CurrentY = CurrentText.Yoff - CurrentFont.Ascender;
		unsigned short Index = 0;
		for (auto i : CurrentText.TextString) {
			float Left = CurrentX + CurrentFont.CharacterSet[i].BearingX;
			float Top = CurrentY + CurrentFont.CharacterSet[i].BearingY;
			CurrentText.Vertices.push_back({ Left, Top, CurrentFont.CharacterSet[i].TexCoordLeft,CurrentFont.CharacterSet[i].TexCoordTop });
			CurrentText.Vertices.push_back({ Left + CurrentFont.CharacterSet[i].Width, Top, CurrentFont.CharacterSet[i].TexCoordRight,CurrentFont.CharacterSet[i].TexCoordTop });
			CurrentText.Vertices.push_back({ Left + CurrentFont.CharacterSet[i].Width, Top - CurrentFont.CharacterSet[i].Height, CurrentFont.CharacterSet[i].TexCoordRight,CurrentFont.CharacterSet[i].TexCoordBottom });
			CurrentText.Vertices.push_back({ Left , Top - CurrentFont.CharacterSet[i].Height, CurrentFont.CharacterSet[i].TexCoordLeft,CurrentFont.CharacterSet[i].TexCoordBottom });
			CurrentText.Indices.push_back(Index + 0);
			CurrentText.Indices.push_back(Index + 1);
			CurrentText.Indices.push_back(Index + 2);
			CurrentText.Indices.push_back(Index + 2);
			CurrentText.Indices.push_back(Index + 3);
			CurrentText.Indices.push_back(Index + 0);
			Index += 4;
			CurrentX += CurrentFont.CharacterSet[i].Advance;
		}
	}

	float CurrentWidthDiv = Viewport.Width / 2.0f;
	float CurrentHeightDiv = Viewport.Height / 2.0f;
	std::vector<Vertex> Temporary; //Vertices in Normalized Device Coords
	for (const auto& Vertexi : CurrentText.Vertices) {
		Temporary.push_back(Vertexi);
		Vertex& TempVertex = Temporary.back();
		TempVertex.Xpos += CurrentText.Xoff;
		TempVertex.Ypos += CurrentText.Yoff;
		TempVertex.Xpos /= CurrentWidthDiv;
		TempVertex.Ypos /= CurrentHeightDiv;
		TempVertex.Xpos += CurrentText.Xscl;
		TempVertex.Ypos += CurrentText.Yscl;
	}

	if (TextDescription.ChangeFlags & TS_CONTENT) {
		//Updating Vertex buffer
		D3D11_BUFFER_DESC BufferDesc;
		BufferDesc.ByteWidth = CurrentText.Vertices.size() * sizeof(Vertex);
		BufferDesc.Usage = D3D11_USAGE_DEFAULT;
		BufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		BufferDesc.CPUAccessFlags = 0u;
		BufferDesc.MiscFlags = 0u;
		BufferDesc.StructureByteStride = 0u;

		D3D11_SUBRESOURCE_DATA SubresourceData = { Temporary.data() };

		CurrentText.VertexBuffer->Release(); //delete old vertex buffer
		Device->CreateBuffer(&BufferDesc, &SubresourceData, &CurrentText.VertexBuffer);
		//Updating Index buffer
		BufferDesc.ByteWidth = CurrentText.Indices.size() * sizeof(unsigned short);
		BufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
		BufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;

		SubresourceData.pSysMem = CurrentText.Indices.data();

		CurrentText.IndexBuffer->Release(); //delete old index buffer
		Device->CreateBuffer(&BufferDesc, &SubresourceData, &CurrentText.IndexBuffer);
	}
	else {
		Context->UpdateSubresource(CurrentText.VertexBuffer, 0u, NULL, Temporary.data(), 0u, 0u);
	}
	
}

void TS_TextSystem::TSDrawTexts(void) {
	Context->IASetInputLayout(InputLayout);
	Context->VSSetShader(VertexShader, NULL, 0u);
	Context->PSSetShader(PixelShader, NULL, 0u);
	Context->PSSetSamplers(0u, 1u, &Sampler);
	Context->OMSetBlendState(BlendState, NULL, 0xFFFFFFFF);
	Context->VSSetConstantBuffers(0u, 1u, &TextConstantBuffer);
	Context->PSSetConstantBuffers(0u, 1u, &TextConstantBuffer);
	for (const auto& Font : Fonts) {
		if (Font.inuse) {
			//Bind Texture atlas
			Context->PSSetShaderResources(0u, 1u, &Font.TextureView);
			for (const auto& Text : Font.Texts) {
				if (Text.inuse) {
					//update color
					TextConst ConstantBufferData;
					ConstantBufferData.R = Text.Red / 255.0f;
					ConstantBufferData.B = Text.Blue / 255.0f;
					ConstantBufferData.G = Text.Green / 255.0f;
					ConstantBufferData.A = Text.Alpha / 255.0f;

					D3D11_MAPPED_SUBRESOURCE MappedSubresource;

					Context->Map(TextConstantBuffer, 0u, D3D11_MAP_WRITE_DISCARD, 0u, &MappedSubresource);
					memcpy(MappedSubresource.pData, &ConstantBufferData, sizeof ConstantBufferData);
					Context->Unmap(TextConstantBuffer, 0u);
					//Bind Vertex buffers
					{
						unsigned stride = sizeof(Vertex);
						unsigned offset = 0u;
						Context->IASetVertexBuffers(0u, 1u, &Text.VertexBuffer, &stride, &offset);
					}
					//Bind Index buffer
					Context->IASetIndexBuffer(Text.IndexBuffer, DXGI_FORMAT_R16_UINT, 0u);

					//Draw
					Context->DrawIndexed(Text.Indices.size(), 0u, 0u);
				}
			}
		}
	}
}

void TSDeleteTextSystem(TS_TextSystem& DeletedTextSystem) {
	for (auto& Font : DeletedTextSystem.Fonts) {
		if (Font.inuse) {
			for (auto& Text : Font.Texts) {
				if (Text.inuse) {
					Text.IndexBuffer->Release();
					Text.VertexBuffer->Release();
				}
			}
			Font.TextureView->Release();
			Font.Texture->Release();
		}
	}
	DeletedTextSystem.Fonts.clear();
	DeletedTextSystem.InputLayout->Release();
	DeletedTextSystem.VertexShader->Release();
	DeletedTextSystem.PixelShader->Release();
	DeletedTextSystem.BlendState->Release();
	DeletedTextSystem.TextConstantBuffer->Release();
	DeletedTextSystem.Sampler->Release();
	DeletedTextSystem.Device->Release();
	DeleteCriticalSection(&DeletedTextSystem.CritSection);
}

void TS_TextSystem::TSDeleteText(TS_TextID TextID) {
	if (GetCurrentThreadId() != OwnerThread) {
		Command cmd;
		cmd.type = DELETE_TEXT;
		cmd.DeleteText.TextID = TextID;
		EnterCriticalSection(&CritSection);
		CommandBuffer.push(cmd);
		LeaveCriticalSection(&CritSection);
		return;
	}
	Text& todelete = Fonts[TextID >> 16].Texts[TextID & 0xffffu];
	todelete.inuse = false;
	todelete.IndexBuffer->Release();
	todelete.VertexBuffer->Release();
}

void TS_TextSystem::TSDeleteFont(TS_FontID FontID) {
	if (GetCurrentThreadId() != OwnerThread) {
		Command cmd;
		cmd.type = DELETE_FONT;
		cmd.DeleteFont.FontID = FontID;
		EnterCriticalSection(&CritSection);
		CommandBuffer.push(cmd);
		LeaveCriticalSection(&CritSection);
		return;
	}
	Font& todelete = Fonts[FontID];
	todelete.inuse = false;
	for (auto& Text : todelete.Texts) {
		if (Text.inuse) {
			Text.IndexBuffer->Release();
			Text.VertexBuffer->Release();
		}
	}
	todelete.TextureView->Release();
	todelete.Texture->Release();
}